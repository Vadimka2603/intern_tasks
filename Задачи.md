Пункт 3, задачи

Упражнение 1.

Разработайте метод palindrome?(string), который будет определять, подана ли ему на вход строка string палиндром, т.е. строка, читающаяся одинаково с начала и с конца, при условии игнорирования пробелов, знаков препинания и регистра. 

Тесты для примеров и проверки:

palindrome?("A man, a plan, a canal -- Panama")  # => true
palindrome?("Madam, I'm Adam!")                  # => true
palindrome?(333)                       			 # => true
palindrome?(nil)                       			 # => false
palindrome?("Abracadabra")                       # => false


Упражнение 2.

Дан массив и числовой диапазон a..b. Разработайте метод coincidence(array, range) для определения элементов массива, значение которых принадлежат этому отрезку. Если не указан хотя бы один из параметров, то должен вернуться пустой массив.

Тесты для примеров и проверки:

coincidence([1, 2, 3, 4, 5], (3..5))  # => [3, 4, 5]
coincidence()  # => []
coincidence([nil, 1, 'foo', 4, 2, 2.5], (1..3)) # => [1, 2, 2.5]


Упражнение 3.

Дан массив. Необходимо разработать метод max_odd(array), который определит максимальный нечетный элемент. Вернуть nil при отсуствии нечетных элементов.

Тесты для примеров и проверки:

max_odd([1, 2, 3, 4, 4]) # => 3
max_odd([21.0, 2, 3, 4, 4]) # => 21
max_odd(['ololo', 2, 3, 4, [1, 2], nil]) # => 3
max_odd(%w[ololo fufufu]) # => nil
max_odd([2, 2, 4]) # => nil


Упражнение 4.

Дан массив целых чисел. Необходимо разработать метод sort_array(array),который поменяет местами минимальные и максимальные элементы массива и добавит в конец массива минимальное значение.

Тесты для примеров и проверки:

sort_array([]) # => []
sort_array([2, 4, 6, 8]) # => [8, 4, 6, 2, 2]
sort_array([1]) # => [1, 1]
sort_array([1, 2, 1, 3]) # => [3, 2, 3, 1, 1]


Упражнение 5.

Разработать метод date_in_future(integer), который вернет дату через указанное число дней. 
Если на вход придет что либо, отличное от Integer, то вывести текущую дату. Формат даты в ответе '01-01-2001 22:33:44'.
Для работы со временем рекомендуется использовать библиотеку active_support.

Тесты для примеров и проверки:

date_in_future([]) # => текущая дата
date_in_future(2) # => текущая дата + 2 дня


Упражнение 6.

Разработать методы для программы Камень-Ножницы-Бумага.
Метод rps_game_winner должен принимать на вход массив примерно следующей структуры [ ["player1", "P"], ["player2", "S"] ], где P - бумага, S - ножницы, R - камень, и функционировать следующим образом:
• если количество игроков больше 2 необходимо вызывать исключение WrongNumberOfPlayersError;
• если ход игроков отличается от ‘R’, ‘P’ или ‘S’ необходимо вызывать исключение NoSuchStrategyError;
• в иных случаях необходимо вернуть имя и ход победителя, если оба игрока походили одинаково - выигрывает первый игрок.

Тесты для примеров и проверки:

rps_game_winner([%w[player1 P], %w[player2 S], %w[player3 S]])) # => WrongNumberOfPlayersError
rps_game_winner([%w[player1 P], %w[player2 A]])) # => NoSuchStrategyError
rps_game_winner([%w[player1 P], %w[player2 S]])) # => 'player2 S'
rps_game_winner([%w[player1 P], %w[player2 P]])) # => 'player1 P'


Упражнение 7.

Анаграмма — литературный приём, состоящий в перестановке букв или звуков определённого слова (или словосочетания), что в результате даёт другое слово или словосочетание.

Разработайте метод combine_anagrams(words_array), который принимает на вход массив слов и разбивает их в группы по анаграммам, регистр букв не имеет значение при определении анаграмм. 

Тест для примера и проверки:
combine_anagrams(%w[cars for potatoes racs four scar creams scream] # =>
[ ["cars", "racs", "scar"], ["four"], ["for"], ["potatoes"], ["creams", "scream"] ]


Упражнение 8.

Написать метод  multiply_numbers(inputs), который вычислит произведение цифр внутри inputs.

Тест для примера и проверки:

multiply_numbers() # => nil
multiply_numbers('ss') # => nil
multiply_numbers('1234') # => 24
multiply_numbers('sssdd34') # => 12
multiply_numbers(2.3) # => 6
multiply_numbers([5, 6, 4]) # => 120


Упражнение 9.

Необходимо разработать метод connect_hashes(hash1, hash2), который соеденит два хеша, значения которых - числа, оставляя приорететными ключи того хэша, сумма значений которого больше (если суммы будут равны, то второй хэш приорететнее), далее удалит ключи со значениями меньше 10 и отсортиртирует получившийся хэш по значениям.

Тест для примера и проверки:

connect_hashes({ a: 2, b: 12 }, { c: 11, e: 5 }) # => { c: 11, b: 12 }
connect_hashes({ a: 13, b: 9, d: 11 }, { c: 12, a: 15 }) # => { d: 11, c: 12, a: 13 }
connect_hashes({ a: 14, b: 12 }, { c: 11, a: 15 }) # => { c: 11, b: 12, a: 15 }


Упражнение 10.

Разработайте функцию count_words(string), которая будет возвращать хэш со статистикой частоты употребления входящих в неё слов. 

Тесты для примеров и проверки:
count_words("A man, a plan, a canal -- Panama")
    # => {'a' => 3, 'man' => 1, 'canal' => 1, 'panama' => 1, 'plan' => 1}
count_words "Doo bee doo bee doo"
    # => {'doo' => 3, 'bee' => 2}


Упражнение 11.

Реализуйте класс Dessert c геттерами и сеттерами для полей класса name и calories, конструктором, принимающим на вход name и calories, а также двумя методами healthy? (возвращает true при условии калорийности десерта менее 200) и delicious? (возвращает true для всех десертов).


Упражнение 12.

Создайте класс JellyBean расшряющий класс Dessert новыми геттерами и сеттерами для атрибута flavor. Измените метод delicious?, он должен возвращать false только в тех случаях, когда flavor равняется "black licorice".


Упражнение 13.

Адаптируйте ваше решение из Упражнения 1, чтобы вместо palindrome?("foo") вы могли его использовать как "foo".palindrome? # => false
